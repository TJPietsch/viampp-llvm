//===--VIAMPPISelDAGToDAG.cpp - A dag to dag inst selector for VIAMPP --------------------------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===-------------------------------------------------------------------------------------------------------------------------===//
//
// This file defines an instruction selector for the VIAMPP target.
//
//===-------------------------------------------------------------------------------------------------------------------------===//

#define DEBUG_TYPE "VIAMPP-isel"

#include "VIAMPP.h"
#include "VIAMPPTargetMachine.h"
#include "VIAMPPMachineFunctionInfo.h"
#include "VIAMPPRegisterInfo.h"
#include "VIAMPPSubtarget.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/TargetLowering.h"
#include "llvm/Config/llvm-config.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

// VIAMPP-specific code to select VIAMPP machine instructions for SelectionDAG operations.
namespace {
class VIAMPPDAGToDAGISel : public SelectionDAGISel {
//  const VIAMPPSubtarget *Subtarget;

public:
	explicit VIAMPPDAGToDAGISel(VIAMPPTargetMachine &TM, CodeGenOpt::Level OptLevel) : SelectionDAGISel(TM, OptLevel) {
//		outs().changeColor(raw_ostream::RED,0);
//		outs() << "VIAMPPDAGToDAGISel::VIAMPPDAGToDAGISel\n";
//		outs().changeColor(raw_ostream::WHITE,0);
	}

	// Return the friendly name for the pass, never returns null
	StringRef getPassName() const override {
//		outs().changeColor(raw_ostream::RED,0);
//		outs() << "--VIAMPPDAGToDAGISel::getPassName: VIAMPP DAG->DAG Pattern Instruction Selection\n";
//		outs().changeColor(raw_ostream::WHITE,0);
		return "VIAMPP DAG->DAG Pattern Instruction Selection";
	}

private:
	bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) override;

	// Include the pieces autogenerated from the target description.
	#include "VIAMPPGenDAGISel.inc"

	// Main method to transform nodes into machine nodes.
	void Select(SDNode *Node) override;

	// Complex Pattern Selector for address selection. (referenced from TableGen'd instruction matching code)
	bool SelectAddr(SDValue Addr, SDValue &BaseAddr);
	bool SelectAddrOff(SDValue Addr, SDValue &BaseAddr, SDValue &Offset);

};
} // end anonymous namespace


// Returns true if it is able pattern match an addressing mode. It returns the operand which make up the maximal addressing mode
// it can match by reference.
bool VIAMPPDAGToDAGISel::SelectAddr(SDValue Addr, SDValue &Base) {
	outs().changeColor(raw_ostream::RED,0);
	outs() << "VIAMPPDAGToDAGISel::SelectAddr\n";
//	Addr.dump();
	outs().changeColor(raw_ostream::WHITE,0);

	if (Addr.getOpcode() == ISD::TargetExternalSymbol || Addr.getOpcode() == ISD::TargetGlobalAddress) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "VIAMPPDAGToDAGISel::SelectAddr: ISD::TargetExternalSymbol or ISD::TargetGlobalAddress\n";
		outs().changeColor(raw_ostream::WHITE,0);

		return false; // direct calls.
	}

	if (Addr.getOpcode() == ISD::FrameIndex) {
//		outs().changeColor(raw_ostream::RED,0);
//		outs() << "VIAMPPDAGToDAGISel::SelectAddr: ISD::FrameIndex\n";
//		outs().changeColor(raw_ostream::WHITE,0);

//		return false; // direct calls.
		Base = Addr;
		return true;						// ********************************* 22.9.21 looks better
	}

	Base = Addr;
//	outs().changeColor(raw_ostream::RED,0);
//	outs() << "VIAMPPDAGToDAGISel::SelectAddr: return FALSE\n";
//	outs().changeColor(raw_ostream::WHITE,0);
	return false;
}

// Returns true if it is able pattern match an addressing mode. It returns the operands which make up the maximal addressing mode
// it can match by reference.
bool VIAMPPDAGToDAGISel::SelectAddrOff(SDValue Addr, SDValue &Base, SDValue &Offset) {
	outs().changeColor(raw_ostream::RED,0);
	outs() << "VIAMPPDAGToDAGISel:SelectAddrOff\n";
	outs().changeColor(raw_ostream::WHITE,0);

	SDLoc dl(Addr);

	if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr)) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: Frame Index\n";
		outs().changeColor(raw_ostream::WHITE,0);

	    Base   = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
	    Offset = CurDAG->getTargetConstant(0, dl, MVT::i64);
		outs().changeColor(raw_ostream::RED,0);
		outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: Frame Index: return\n";
		outs().changeColor(raw_ostream::WHITE,0);
	    return true;
	}

	if ((Addr.getOpcode() == ISD::TargetExternalSymbol || Addr.getOpcode() == ISD::TargetGlobalAddress)) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "VIAMPPDAGToDAGISel::SelectAddrOff: ISD::TargetExternalSymbol or ISD::TargetGlobalAddress\n";
		outs().changeColor(raw_ostream::WHITE,0);

		return false;
	}

	// Addresses of the form FI+const or FI|const
	if (CurDAG->isBaseWithConstantOffset(Addr)) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: Base with Constant Offset\n";
		outs().changeColor(raw_ostream::WHITE,0);
	    ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1));
	    if (isInt<16>(CN->getSExtValue())) {
	    	// If the first operand is a FI, get the TargetFI Node
	    	if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0)))
	    		Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
	    	else
	    		Base = Addr.getOperand(0);

	    	Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(CN), MVT::i64);
	    	return true;
	    }
	}

	// Operand is a result from an ADD.
	if (Addr.getOpcode() == ISD::ADD) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: ADD\n";
		outs().changeColor(raw_ostream::WHITE,0);
	    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Addr.getOperand(1))) {
			outs().changeColor(raw_ostream::RED,0);
			outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: ConstantSDNode\n";
			outs().changeColor(raw_ostream::WHITE,0);
	    	if (isUInt<16>(CN->getZExtValue())) {
	    		// If the first operand is a FI, get the TargetFI Node
	    		if (FrameIndexSDNode *FIN = dyn_cast<FrameIndexSDNode>(Addr.getOperand(0))) {
	    			Base = CurDAG->getTargetFrameIndex(FIN->getIndex(), MVT::i64);
	    		} else {
	    			Base = Addr.getOperand(0);
	    		}

	    		Offset = CurDAG->getTargetConstant(CN->getZExtValue(), SDLoc(CN), MVT::i64);
	    		return true;
	    	}
	    }
	}

	outs().changeColor(raw_ostream::RED,0);
	outs() << "----VIAMPPDAGToDAGISel:SelectAddrOff: Default ------------*****--------------\n";
	outs().changeColor(raw_ostream::WHITE,0);

	Base   = Addr;
	Offset = CurDAG->getTargetConstant(0, dl, MVT::i64);

	return true;
}

// SelectInlineAsmMemoryOperand - Select the specified address as a target addressing mode, according to the specified constraint.
// If this does not match or is not implemented, return true.  The resultant operands (which will appear in the machine
// instruction) should be added to the OutOps vector.
bool VIAMPPDAGToDAGISel::SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID, std::vector<SDValue> &OutOps) {
	outs().changeColor(raw_ostream::RED,0);
	outs() << "--VIAMPPDAGToDAGISel::SelectInlineAsmMemoryOperand\n";
	outs().changeColor(raw_ostream::WHITE,0);
	SDValue Op0, Op1;
	switch (ConstraintID) {
	default: return false;

	case InlineAsm::Constraint_m:   // memory
		if (!SelectAddr(Op, Op0)) {
			OutOps.push_back(Op0);
			return true;
		}
		if (!SelectAddrOff(Op, Op0, Op1)) {
			OutOps.push_back(Op0);
			OutOps.push_back(Op1);
			return true;
		}
	}

	return false;
}

void VIAMPPDAGToDAGISel::Select(SDNode *Node) {

	unsigned Opcode = Node->getOpcode();
	SDLoc DL(Node);

	// Dump information about the Node being selected.
	outs().changeColor(raw_ostream::RED,0);
	outs() << "--VIAMPPDAGToDAGISel::Select: Selecting Opcode:"; Node->dump(CurDAG); outs() << "\n";
	outs().changeColor(raw_ostream::WHITE,0);

	// If we have a custom node, we already have selected!
	if (Node->isMachineOpcode()) {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "--VIAMPPDAGToDAGISel::Select: Custom - Already selected\n";
		outs().changeColor(raw_ostream::WHITE,0);
		Node->setNodeId(-1);
		return;
 	}

	// Custom selection stuff.
	// Instruction Selection not handled by the auto-generated tablegen selection should be handled here.
	switch (Opcode) {
	default:
		break;
	case ISD::STORE: {
		outs().changeColor(raw_ostream::RED,0);
		outs() << "--VIAMPPDAGToDAGISel::Select: Custom - STORE\n";
		StoreSDNode *SN = cast<StoreSDNode>(Node);
		MVT VT = SN->getMemoryVT().getSimpleVT();
		if (VT.SimpleTy == MVT::i8 || VT.SimpleTy == MVT::i16)
			outs() << "--VIAMPPDAGToDAGISel::Select: Custom - STORE: Value Type is i8 or i16\n";

		outs().changeColor(raw_ostream::WHITE,0);
		break;
	}
	case ISD::SIGN_EXTEND:
		outs().changeColor(raw_ostream::RED,0);
		outs() << "--VIAMPPDAGToDAGISel::Select: Custom - ASSERT SIGN EXT\n";
		outs().changeColor(raw_ostream::WHITE,0);
		break;
	case ISD::TRUNCATE:
		outs().changeColor(raw_ostream::RED,0);
		outs() << "--VIAMPPDAGToDAGISel::Select: Custom - TRUNCATE\n";
		outs().changeColor(raw_ostream::WHITE,0);
		break;
	}  // end switch (opcode)

	// Select the default instruction.
//	outs().changeColor(raw_ostream::RED,0);
//	outs() << "--VIAMPPDAGToDAGISel::Select: SelectCode\n";
//	outs().changeColor(raw_ostream::WHITE,0);
	SelectCode(Node);
}

// createVIAMPPISelDag - This pass converts a legalized DAG into a VIAMPP-specific DAG, ready for instruction scheduling.
FunctionPass *llvm::createVIAMPPISelDag(VIAMPPTargetMachine &TM, CodeGenOpt::Level OptLevel) {
	return new VIAMPPDAGToDAGISel(TM, OptLevel);
}
